# b main.main

# instance
# b instance/beat.go:175
# b instance/beat.go:354
# b instance.(*Beat).createOutput
# b instance.(*Beat).launch
# b instance.handleError

# outputs
# b outputs.Load

# autodiscover
# b autodiscover.(*registry).AddProvider
# b autodiscover.NewAutodiscover
# b autodiscover.(*Autodiscover).Start
# b autodiscover.(*Autodiscover).handleStart
# b autodiscover.(*Autodiscover).printEvent
# b autodiscover/autodiscover.go:217

# b cfgfile.(*RunnerList).Reload

# libbeat/autodiscover/providers/kubernetes
# b kubernetes.AutodiscoverBuilder
# b kubernetes.NewPodEventer
# b kubernetes.(*pod).OnAdd
# b kubernetes.(*pod).OnUpdate
# b kubernetes.(*pod).OnDelete
# b kubernetes/pod.go:319

# filebeat/beater
# b beater.newBeater
# b beater.newCrawler
# b beater.(*crawler).Start
# b beater.(*crawler).Stop
# b beater.(*crawler).startInput
# b beater.(*Filebeat).Run
# b beater.(*filebeatStore).Access
# b beater.(*registrarLogger).Published

# filebeat/beater.registrar
# b registrar.New
# b registrar.readStatesFrom
# b registrar.(*Registrar).Run
# b registrar.(*Registrar).onEvents
# b registrar.(*Registrar).commitStateUpdates

# input
# b input.New
# b input.Plugin
# b input.(*Runner).Stop
# b input.(*Runner).stop
# b input.NewRunnerFactory
# b input.(*RunnerFactory).Create

# input/file
# b input/file.NewState
# b input/file.(*States).FindPrevious

# input/container
# b container.NewInput

# input/log
# b log.NewInput
# b log.(*Input).Run
# b log.(*Input).scan
# b log.(*Input).harvestExistingFile
# b log.(*Input).getFiles
# b log.subOutletWrap
# b log/input.go:679
# b log.(*Input).loadStates
# b log.getFileState

# b input/input.go:136
# b log/input.go:233
# b log/input.go:679

# harvester
# b log.NewHarvester
# b log.(*Harvester).Setup
# b log.(*Harvester).Run
# b log.(*Harvester).stop
# b log/harvester.go:276
# b log/harvester.go:323
# b memqueue.(*openState).publish
# b harvester.(*Forwarder).Send
# b log/harvester.go:325
# b channel.(*subOutlet).Close
# b channel/util.go:115
# b channel/util.go:117
# b channel.CloseOnSignal

# filebeat/channel
# b channel.(*OutletFactory).Create
b channel.(*pipelineConnector).ConnectWith
# b channel.(*outlet).OnEvent
# b pipeline.(*client).publish
# b memqueue.(*ackProducer).Publish
# b channel.(ConnectorFunc).ConnectWith
# b channel.(*pipelineConnector).ConnectWith

# beater
# b channel/util.go:45
# b acker.(*trackingACKer).AddEvent
# b beater.newRegistrarLogger
# b beater/acker.go:60
# b logp/logger.go:53
# b beater.(*registrarLogger).Published
# b beater.(*finishedLogger).Published
# b pipeline.(*client).onPublished
# b pipeline.(*clientCloseWaiter).AddEvent
# b pipeline.newClientCloseWaiter # 未被调用
# b pipeline.(*client).Publish

# libbeat/publisher/pipeline
# b pipeline.(*client).Publish
# b pipeline.(*Pipeline).ConnectWith
# b pipeline/pipeline.go:302
# b pipeline.makeClientWorker
# b pipeline.newOutputController
# b pipeline.(*outputController).Set
# b pipeline.newEventConsumer
# b pipeline.(*eventConsumer).loop
# b pipeline.newBatch

# console
# b console.newConsole
# b console.Publish

# codec.json
# b codec/json.makeEvent

# b compat.(composeFactory).CheckConfig

# memqueue
# b memqueue.NewQueue
# b memqueue.(*consumer).Get
# b memqueue.(*ackLoop).handleBatchSig
# b memqueue.(*bufferingEventLoop).handleInsert
# b memqueue.(*bufferingEventLoop).processACK
# b pipeline.(*waitCloser).inc
# b pipeline.(*pipelineEventer).OnACK
# b eventloop.go:548
# b memqueue.newBufferingEventLoop

# b statestore.(*Store).Remove

# b memlog.New
# b memlog.openStore
# b memlog.loadDataFile
# b memlog.loadLogFile
# b memlog.(*store).Checkpoint
# b memlog.(*store).logOperation
# b memlog.(*diskstore).LogOperation
# b memlog.(*diskstore).WriteCheckpoint
# b memlog.(*diskstore).tryOpenLog
# b memlog.New

# clearall

g